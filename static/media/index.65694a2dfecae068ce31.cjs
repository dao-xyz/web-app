var u8a=require("uint8arrays"),basics=require("multiformats/basics"),sha256$1=require("@stablelib/sha256"),sha3=require("js-sha3"),elliptic=require("elliptic"),ed25519=require("@stablelib/ed25519"),canonicalizeData=require("canonicalize"),bech32=require("bech32"),x25519=require("@stablelib/x25519"),xchacha20poly1305=require("@stablelib/xchacha20poly1305"),random=require("@stablelib/random"),fromString=require("uint8arrays/from-string");function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,t}var u8a__namespace=_interopNamespace(u8a),sha3__default=_interopDefaultLegacy(sha3),elliptic__default=_interopDefaultLegacy(elliptic),canonicalizeData__default=_interopDefaultLegacy(canonicalizeData);function bytesToBase64url(e){return u8a__namespace.toString(e,"base64url")}function base64ToBytes(e){const t=e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"");return u8a__namespace.fromString(t,"base64url")}function base58ToBytes(e){return u8a__namespace.fromString(e,"base58btc")}function bytesToBase58(e){return u8a__namespace.toString(e,"base58btc")}function hexToBytes(e){const t=e.startsWith("0x")?e.substring(2):e;return u8a__namespace.fromString(t.toLowerCase(),"base16")}function encodeBase64url(e){return bytesToBase64url(u8a__namespace.fromString(e))}function decodeBase64url(e){return u8a__namespace.toString(base64ToBytes(e))}function bytesToHex(e){return u8a__namespace.toString(e,"base16")}function stringToBytes(e){return u8a__namespace.fromString(e)}function toJose({r:e,s:t,recoveryParam:r},n){const i=new Uint8Array(n?65:64);if(i.set(u8a__namespace.fromString(e,"base16"),0),i.set(u8a__namespace.fromString(t,"base16"),32),n){if(void 0===r)throw new Error("Signer did not return a recoveryParam");i[64]=r}return bytesToBase64url(i)}function fromJose(e){const t=base64ToBytes(e);if(t.length<64||t.length>65)throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${t.length}`);return{r:bytesToHex(t.slice(0,32)),s:bytesToHex(t.slice(32,64)),recoveryParam:65===t.length?t[64]:void 0}}function toSealed(e,t){return u8a__namespace.concat([base64ToBytes(e),base64ToBytes(t)])}const hexMatcher=/^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/,base58Matcher=/^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/,base64Matcher=/^([0-9a-zA-Z=\-_+/]{43}|[0-9a-zA-Z=\-_+/]{86})(={0,2})$/;function parseKey(e){if("string"==typeof e){if(hexMatcher.test(e))return hexToBytes(e);if(base58Matcher.test(e))return base58ToBytes(e);if(base64Matcher.test(e))return base64ToBytes(e);throw TypeError("bad_key: Invalid private key format")}if(e instanceof Uint8Array)return e;throw TypeError("bad_key: Invalid private key format")}function leftpad(e,t=64){return e.length===t?e:"0".repeat(t-e.length)+e}function sha256(e){const t="string"==typeof e?u8a__namespace.fromString(e):e;return sha256$1.hash(t)}function keccak(e){return new Uint8Array(sha3__default.default.keccak_256.arrayBuffer(e))}function toEthereumAddress(e){const t=u8a__namespace.fromString(e.slice(2),"base16");return`0x${u8a__namespace.toString(keccak(t).slice(-20),"base16")}`}function writeUint32BE(e,t=new Uint8Array(4)){const r=u8a__namespace.fromString(e.toString(),"base10");return t.set(r,4-r.length),t}const lengthAndInput=e=>u8a__namespace.concat([writeUint32BE(e.length),e]);function concatKDF(e,t,r,n,i){if(256!==t)throw new Error(`Unsupported key length: ${t}`);const o=u8a__namespace.concat([lengthAndInput(u8a__namespace.fromString(r)),lengthAndInput(void 0===n?new Uint8Array(0):n),lengthAndInput(void 0===i?new Uint8Array(0):i),writeUint32BE(t)]);return sha256$1.hash(u8a__namespace.concat([writeUint32BE(1),e,o]))}const secp256k1$1=new elliptic__default.default.ec("secp256k1");function ES256KSigner(e,t=!1){const r=parseKey(e);if(32!==r.length)throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${r.length}`);const n=secp256k1$1.keyFromPrivate(r);return function(e){try{const{r,s:i,recoveryParam:o}=n.sign(sha256(e));return Promise.resolve(toJose({r:leftpad(r.toString("hex")),s:leftpad(i.toString("hex")),recoveryParam:o},t))}catch(e){return Promise.reject(e)}}}function SimpleSigner(e){const t=ES256KSigner(e,!0);return function(e){try{return Promise.resolve(t(e)).then(fromJose)}catch(e){return Promise.reject(e)}}}function EllipticSigner(e){return ES256KSigner(e)}function EdDSASigner(e){const t=parseKey(e);if(64!==t.length)throw new Error(`bad_key: Invalid private key format. Expecting 64 bytes, but got ${t.length}`);return function(e){try{const r="string"==typeof e?stringToBytes(e):e,n=ed25519.sign(t,r);return Promise.resolve(bytesToBase64url(n))}catch(e){return Promise.reject(e)}}}function NaclSigner(e){return EdDSASigner(e)}function instanceOfEcdsaSignature(e){return"object"==typeof e&&"r"in e&&"s"in e}function ES256KSignerAlg(e){return function sign(t,r){try{return Promise.resolve(r(t)).then((function(t){if(instanceOfEcdsaSignature(t))return toJose(t,e);if(e&&void 0===fromJose(t).recoveryParam)throw new Error("not_supported: ES256K-R not supported when signer doesn't provide a recovery param");return t}))}catch(e){return Promise.reject(e)}}}function Ed25519SignerAlg(){return function sign(e,t){try{return Promise.resolve(t(e)).then((function(e){if(instanceOfEcdsaSignature(e))throw new Error("invalid_config: expected a signer function that returns a string instead of signature object");return e}))}catch(e){return Promise.reject(e)}}}const algorithms$1={ES256K:ES256KSignerAlg(),"ES256K-R":ES256KSignerAlg(!0),Ed25519:Ed25519SignerAlg(),EdDSA:Ed25519SignerAlg()};function SignerAlg(e){const t=algorithms$1[e];if(!t)throw new Error(`not_supported: Unsupported algorithm ${e}`);return t}const zl=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],zr=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],sl=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],sr=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11],hl=[0,1518500249,1859775393,2400959708,2840853838],hr=[1352829926,1548603684,1836072691,2053994217,0];function rotl(e,t){return e<<t|e>>>32-t}function fn1(e,t,r,n,i,o,c,s){return rotl(e+(t^r^n)+o+c|0,s)+i|0}function fn2(e,t,r,n,i,o,c,s){return rotl(e+(t&r|~t&n)+o+c|0,s)+i|0}function fn3(e,t,r,n,i,o,c,s){return rotl(e+((t|~r)^n)+o+c|0,s)+i|0}function fn4(e,t,r,n,i,o,c,s){return rotl(e+(t&n|r&~n)+o+c|0,s)+i|0}function fn5(e,t,r,n,i,o,c,s){return rotl(e+(t^(r|~n))+o+c|0,s)+i|0}class Ripemd160{constructor(e=64){this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this._blockOffset=0,this._block=void 0,this._blockSize=void 0,this._length=[0,0,0,0],this._finalized=void 0,this.update=e=>{if(this._finalized)throw new Error("Digest already called");const t=this._block;let r=0;for(;this._blockOffset+e.length-r>=this._blockSize;){for(let n=this._blockOffset;n<this._blockSize;)t[n++]=e[r++];this._update(),this._blockOffset=0}for(;r<e.length;)t[this._blockOffset++]=e[r++];for(let t=0,r=8*e.length;r>0;++t)this._length[t]+=r,r=this._length[t]/4294967296|0,r>0&&(this._length[t]-=4294967296*r);return this},this.digest=()=>{if(this._finalized)throw new Error("Digest already called");this._finalized=!0;const e=this._digest();this._block.fill(0),this._blockOffset=0;for(let e=0;e<4;++e)this._length[e]=0;return e},this._update=()=>{const e=new Array(16),t=new DataView(this._block.buffer);for(let r=0;r<16;++r)e[r]=e[r]=t.getInt32(4*r,!0);let r=0|this._a,n=0|this._b,i=0|this._c,o=0|this._d,c=0|this._e,s=0|this._a,a=0|this._b,u=0|this._c,l=0|this._d,d=0|this._e;for(let t=0;t<80;t+=1){let f,h;t<16?(f=fn1(r,n,i,o,c,e[zl[t]],hl[0],sl[t]),h=fn5(s,a,u,l,d,e[zr[t]],hr[0],sr[t])):t<32?(f=fn2(r,n,i,o,c,e[zl[t]],hl[1],sl[t]),h=fn4(s,a,u,l,d,e[zr[t]],hr[1],sr[t])):t<48?(f=fn3(r,n,i,o,c,e[zl[t]],hl[2],sl[t]),h=fn3(s,a,u,l,d,e[zr[t]],hr[2],sr[t])):t<64?(f=fn4(r,n,i,o,c,e[zl[t]],hl[3],sl[t]),h=fn2(s,a,u,l,d,e[zr[t]],hr[3],sr[t])):(f=fn5(r,n,i,o,c,e[zl[t]],hl[4],sl[t]),h=fn1(s,a,u,l,d,e[zr[t]],hr[4],sr[t])),r=c,c=o,o=rotl(i,10),i=n,n=f,s=d,d=l,l=rotl(u,10),u=a,a=h}const f=this._b+i+l|0;this._b=this._c+o+d|0,this._c=this._d+c+s|0,this._d=this._e+r+a|0,this._e=this._a+n+u|0,this._a=f},this._digest=()=>{this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56);const e=new DataView(this._block.buffer);e.setUint32(56,this._length[0],!0),e.setUint32(60,this._length[1],!0),this._block=new Uint8Array(e.buffer),this._update();const t=new DataView(new Uint8Array(20).buffer);return t.setInt32(0,this._a,!0),t.setInt32(4,this._b,!0),t.setInt32(8,this._c,!0),t.setInt32(12,this._d,!0),t.setInt32(16,this._e,!0),new Uint8Array(t.buffer)},this._block=new Uint8Array(e),this._blockSize=e,this._blockOffset=0,this._length=[0,0,0,0],this._finalized=!1}}const publicKeyToAddress$1=(e,t)=>{const r=u8a__namespace.toString(base58ToBytes(t).slice(0,1),"hex"),n=u8a__namespace.fromString(e,"hex"),i=(new Ripemd160).update(sha256(n)).digest(),o=r+u8a__namespace.toString(i,"hex"),c=sha256(u8a__namespace.fromString(o,"hex")),s=sha256(c),a=o+u8a__namespace.toString(s,"hex").substring(0,8);return bytesToBase58(u8a__namespace.fromString(a,"hex"))},EC=elliptic__default.default.ec,publicKeyToAddress=(e,t)=>{const r=new EC("secp256k1").keyFromPublic(e,"hex").getPublic().encode("hex",!0),n=u8a__namespace.fromString(r,"hex"),i=(new Ripemd160).update(sha256(n)).digest(),o=bech32.bech32.toWords(i);return bech32.bech32.encode(t,o).replace(t,"")},verifyBlockchainAccountId=(e,t)=>{if(t){const r=t.split(":");switch(r[0]){case"bip122":r[r.length-1]=publicKeyToAddress$1(e,r[r.length-1]);break;case"cosmos":r[r.length-1]=publicKeyToAddress(e,r[1]);break;case"eip155":r[r.length-1]=toEthereumAddress(e);break;default:return!1}return r.join(":")===t}return!1},secp256k1=new elliptic__default.default.ec("secp256k1");function toSignatureObject(e,t=!1){const r=base64ToBytes(e);if(r.length!==(t?65:64))throw new Error("wrong signature length");const n={r:bytesToHex(r.slice(0,32)),s:bytesToHex(r.slice(32,64))};return t&&(n.recoveryParam=r[64]),n}function extractPublicKeyBytes(e){if(e.publicKeyBase58)return base58ToBytes(e.publicKeyBase58);if(e.publicKeyBase64)return base64ToBytes(e.publicKeyBase64);if(e.publicKeyHex)return hexToBytes(e.publicKeyHex);if(e.publicKeyJwk&&"secp256k1"===e.publicKeyJwk.crv&&e.publicKeyJwk.x&&e.publicKeyJwk.y)return hexToBytes(secp256k1.keyFromPublic({x:bytesToHex(base64ToBytes(e.publicKeyJwk.x)),y:bytesToHex(base64ToBytes(e.publicKeyJwk.y))}).getPublic("hex"));if(e.publicKeyMultibase){const{base16:t,base58btc:r,base64:n,base64url:i}=basics.bases;return t.decoder.or(r.decoder.or(n.decoder.or(i.decoder))).decode(e.publicKeyMultibase)}return new Uint8Array}function verifyES256K(e,t,r){const n=sha256(e),i=toSignatureObject(t),o=r.filter((({ethereumAddress:e,blockchainAccountId:t})=>void 0===e&&void 0===t)),c=r.filter((({ethereumAddress:e,blockchainAccountId:t})=>void 0!==e||void 0!==t));let s=o.find((e=>{try{const t=extractPublicKeyBytes(e);return secp256k1.keyFromPublic(t).verify(n,i)}catch(e){return!1}}));if(!s&&c.length>0&&(s=verifyRecoverableES256K(e,t,c)),!s)throw new Error("invalid_signature: Signature invalid for JWT");return s}function verifyRecoverableES256K(e,t,r){let n;if(t.length>86)n=[toSignatureObject(t,!0)];else{const e=toSignatureObject(t,!1);n=[{...e,recoveryParam:0},{...e,recoveryParam:1}]}const i=n.map((t=>{const n=sha256(e),i=secp256k1.recoverPubKey(n,t,t.recoveryParam),o=i.encode("hex"),c=i.encode("hex",!0),s=toEthereumAddress(o);return r.find((e=>{var t,r,n;const i=bytesToHex(extractPublicKeyBytes(e));return i===o||i===c||(null==(t=e.ethereumAddress)?void 0:t.toLowerCase())===s||(null==(r=e.blockchainAccountId)||null==(n=r.split("@eip155"))?void 0:n[0].toLowerCase())===s||verifyBlockchainAccountId(o,e.blockchainAccountId)}))})).filter((e=>void 0!==e));if(0===i.length)throw new Error("invalid_signature: Signature invalid for JWT");return i[0]}function verifyEd25519(e,t,r){const n=stringToBytes(e),i=base64ToBytes(t),o=r.find((e=>ed25519.verify(extractPublicKeyBytes(e),n,i)));if(!o)throw new Error("invalid_signature: Signature invalid for JWT");return o}const algorithms={ES256K:verifyES256K,"ES256K-R":verifyRecoverableES256K,Ed25519:verifyEd25519,EdDSA:verifyEd25519};function VerifierAlgorithm(e){const t=algorithms[e];if(!t)throw new Error(`not_supported: Unsupported algorithm ${e}`);return t}VerifierAlgorithm.toSignatureObject=toSignatureObject;const resolveAuthenticator=function(e,t,r,n){try{const i=SUPPORTED_PUBLIC_KEY_TYPES[t];if(!i||0===i.length)throw new Error(`not_supported: No supported signature types for algorithm ${t}`);let o;return Promise.resolve(e.resolve(r,{accept:DID_JSON})).then((function(e){var c,s,a,u,l;if(o=-1===Object.getOwnPropertyNames(e).indexOf("didDocument")?{didDocument:e,didDocumentMetadata:{},didResolutionMetadata:{contentType:DID_JSON}}:e,null!=(c=o.didResolutionMetadata)&&c.error||null==o.didDocument){const{error:e,message:t}=o.didResolutionMetadata;throw new Error(`resolver_error: Unable to resolve DID document for ${r}: ${e}, ${t||""}`)}const getPublicKeyById=(e,t)=>{const r=e.filter((({id:e})=>t===e));return r.length>0?r[0]:null};let d=[...(null==(s=o)||null==(a=s.didDocument)?void 0:a.verificationMethod)||[],...(null==(u=o)||null==(l=u.didDocument)?void 0:l.publicKey)||[]];var f;"string"==typeof n&&(n.startsWith("assertion")&&!Object.getOwnPropertyNames(null==(f=o)?void 0:f.didDocument).includes("assertionMethod")&&(o.didDocument={...o.didDocument},o.didDocument.assertionMethod=[...d.map((e=>e.id))]),d=(o.didDocument[n]||[]).map((e=>"string"==typeof e?getPublicKeyById(d,e):"string"==typeof e.publicKey?getPublicKeyById(d,e.publicKey):e)).filter((e=>null!=e)));const h=d.filter((({type:e})=>i.find((t=>t===e))));if("string"==typeof n&&(!h||0===h.length))throw new Error(`no_suitable_keys: DID document for ${r} does not have public keys suitable for ${t} with ${n} purpose`);if(!h||0===h.length)throw new Error(`no_suitable_keys: DID document for ${r} does not have public keys for ${t}`);return{authenticators:h,issuer:r,didResolutionResult:o}}))}catch(e){return Promise.reject(e)}},verifyJWT=function(e,t={resolver:void 0,auth:void 0,audience:void 0,callbackUrl:void 0,skewTime:void 0,proofPurpose:void 0}){try{if(!t.resolver)throw new Error("missing_resolver: No DID resolver has been configured");const{payload:r,header:n,signature:i,data:o}=decodeJWT(e),c=Object.prototype.hasOwnProperty.call(t,"auth")?t.auth?"authentication":void 0:t.proofPurpose;if(!r.iss)throw new Error("invalid_jwt: JWT iss is required");let s="";if(r.iss===SELF_ISSUED_V2){if(!r.sub)throw new Error("invalid_jwt: JWT sub is required");s=void 0===r.sub_jwk?r.sub:(n.kid||"").split("#")[0]}else if(r.iss===SELF_ISSUED_V0_1){if(!r.did)throw new Error("invalid_jwt: JWT did is required");s=r.did}else s=r.iss;if(!s)throw new Error("invalid_jwt: No DID has been found in the JWT");return Promise.resolve(resolveAuthenticator(t.resolver,n.alg,s,c)).then((function({didResolutionResult:c,authenticators:s,issuer:a}){return Promise.resolve(verifyJWSDecoded({header:n,data:o,signature:i},s)).then((function(n){const i=Math.floor(Date.now()/1e3),o=void 0!==t.skewTime&&t.skewTime>=0?t.skewTime:NBF_SKEW;if(n){const s=i+o;if(r.nbf){if(r.nbf>s)throw new Error(`invalid_jwt: JWT not valid before nbf: ${r.nbf}`)}else if(r.iat&&r.iat>s)throw new Error(`invalid_jwt: JWT not valid yet (issued in the future) iat: ${r.iat}`);if(r.exp&&r.exp<=i-o)throw new Error(`invalid_jwt: JWT has expired: exp: ${r.exp} < now: ${i}`);if(r.aud){if(!t.audience&&!t.callbackUrl)throw new Error("invalid_config: JWT audience is required but your app address has not been configured");if(void 0===(Array.isArray(r.aud)?r.aud:[r.aud]).find((e=>t.audience===e||t.callbackUrl===e)))throw new Error("invalid_config: JWT audience does not match your DID or callback url")}return{payload:r,didResolutionResult:c,issuer:a,signer:n,jwt:e}}throw new Error("invalid_signature: JWT not valid. issuer DID document does not contain a verificationMethod that matches the signature.")}))}))}catch(e){return Promise.reject(e)}},createJWT=function(e,{issuer:t,signer:r,alg:n,expiresIn:i,canonicalize:o},c={}){try{if(!r)throw new Error("missing_signer: No Signer functionality has been configured");if(!t)throw new Error("missing_issuer: No issuing DID has been configured");c.typ||(c.typ="JWT"),c.alg||(c.alg=n);const s={iat:Math.floor(Date.now()/1e3),exp:void 0};if(i){if("number"!=typeof i)throw new Error("invalid_argument: JWT expiresIn is not a number");s.exp=(e.nbf||s.iat)+Math.floor(i)}const a={...s,...e,iss:t};return createJWS(a,r,c,{canonicalize:o})}catch(e){return Promise.reject(e)}},createJWS=function(e,t,r={},n={}){try{r.alg||(r.alg=defaultAlg);const i="string"==typeof e?e:encodeSection(e,n.canonicalize),o=[encodeSection(r,n.canonicalize),i].join("."),c=SignerAlg(r.alg);return Promise.resolve(c(o,t)).then((function(e){return[o,e].join(".")}))}catch(e){return Promise.reject(e)}},SUPPORTED_PUBLIC_KEY_TYPES={ES256K:["EcdsaSecp256k1VerificationKey2019","EcdsaSecp256k1RecoveryMethod2020","Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],"ES256K-R":["EcdsaSecp256k1VerificationKey2019","EcdsaSecp256k1RecoveryMethod2020","Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],Ed25519:["ED25519SignatureVerification","Ed25519VerificationKey2018"],EdDSA:["ED25519SignatureVerification","Ed25519VerificationKey2018"]},SELF_ISSUED_V2="https://self-issued.me/v2",SELF_ISSUED_V0_1="https://self-issued.me",defaultAlg="ES256K",DID_JSON="application/did+json";function encodeSection(e,t=!1){return encodeBase64url(t?canonicalizeData__default.default(e):JSON.stringify(e))}const NBF_SKEW=300;function decodeJWS(e){const t=e.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);if(t)return{header:JSON.parse(decodeBase64url(t[1])),payload:t[2],signature:t[3],data:`${t[1]}.${t[2]}`};throw new Error("invalid_argument: Incorrect format JWS")}function decodeJWT(e){if(!e)throw new Error("invalid_argument: no JWT passed into decodeJWT");try{const t=decodeJWS(e);return Object.assign(t,{payload:JSON.parse(decodeBase64url(t.payload))})}catch(e){throw new Error("invalid_argument: Incorrect format JWT")}}function verifyJWSDecoded({header:e,data:t,signature:r},n){Array.isArray(n)||(n=[n]);return VerifierAlgorithm(e.alg)(t,r,n)}function verifyJWS(e,t){return verifyJWSDecoded(decodeJWS(e),t)}function _for(e,t,r){for(var n;;){var i=e();if(_isSettledPact(i)&&(i=i.v),!i)return o;if(i.then){n=0;break}var o=r();if(o&&o.then){if(!_isSettledPact(o)){n=1;break}o=o.s}if(t){var c=t();if(c&&c.then&&!_isSettledPact(c)){n=2;break}}}var s=new _Pact,a=_settle.bind(null,s,2);return(0===n?i.then(_resumeAfterTest):1===n?o.then(_resumeAfterBody):c.then(_resumeAfterUpdate)).then(void 0,a),s;function _resumeAfterBody(n){o=n;do{if(t&&(c=t())&&c.then&&!_isSettledPact(c))return void c.then(_resumeAfterUpdate).then(void 0,a);if(!(i=e())||_isSettledPact(i)&&!i.v)return void _settle(s,1,o);if(i.then)return void i.then(_resumeAfterTest).then(void 0,a);_isSettledPact(o=r())&&(o=o.v)}while(!o||!o.then);o.then(_resumeAfterBody).then(void 0,a)}function _resumeAfterTest(e){e?(o=r())&&o.then?o.then(_resumeAfterBody).then(void 0,a):_resumeAfterBody(o):_settle(s,1,o)}function _resumeAfterUpdate(){(i=e())?i.then?i.then(_resumeAfterTest).then(void 0,a):_resumeAfterTest(i):_settle(s,1,o)}}const decryptJWE=function(e,t){try{function _temp5(e){if(null===o)throw new Error("failure: Failed to decrypt");return o}validateJWE(e);const r=JSON.parse(decodeBase64url(e.protected));if(r.enc!==t.enc)throw new Error(`not_supported: Decrypter does not supported: '${r.enc}'`);const n=toSealed(e.ciphertext,e.tag),i=u8a.fromString(e.aad?`${e.protected}.${e.aad}`:e.protected);let o=null;const c="dir"===r.alg&&"dir"===t.alg?Promise.resolve(t.decrypt(n,base64ToBytes(e.iv),i)).then((function(e){o=e})):function(){if(e.recipients&&0!==e.recipients.length){let c=0;return _for((function(){return!o&&c<e.recipients.length}),(function(){return c++}),(function(){const s=e.recipients[c];Object.assign(s.header,r);const a=function(){if(s.header.alg===t.alg)return Promise.resolve(t.decrypt(n,base64ToBytes(e.iv),i,s)).then((function(e){o=e}))}();if(a&&a.then)return a.then((function(){}))}))}throw new Error("bad_jwe: missing recipients")}();return Promise.resolve(c&&c.then?c.then(_temp5):_temp5())}catch(s){return Promise.reject(s)}},_iteratorSymbol="undefined"!=typeof Symbol?Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator")):"@@iterator";function _settle(e,t,r){if(!e.s){if(r instanceof _Pact){if(!r.s)return void(r.o=_settle.bind(null,e,t));1&t&&(t=r.s),r=r.v}if(r&&r.then)return void r.then(_settle.bind(null,e,t),_settle.bind(null,e,2));e.s=t,e.v=r;const n=e.o;n&&n(e)}}const _Pact=function(){function _Pact(){}return _Pact.prototype.then=function(e,t){const r=new _Pact,n=this.s;if(n){const i=1&n?e:t;if(i){try{_settle(r,1,i(this.v))}catch(e){_settle(r,2,e)}return r}return this}return this.o=function(n){try{const i=n.v;1&n.s?_settle(r,1,e?e(i):i):t?_settle(r,1,t(i)):_settle(r,2,i)}catch(e){_settle(r,2,e)}},r},_Pact}();function _isSettledPact(e){return e instanceof _Pact&&1&e.s}function _forTo(e,t,r){var n,i,o=-1;return function _cycle(c){try{for(;++o<e.length&&(!r||!r());)if((c=t(o))&&c.then){if(!_isSettledPact(c))return void c.then(_cycle,i||(i=_settle.bind(null,n=new _Pact,2)));c=c.v}n?_settle(n,1,c):n=c}catch(e){_settle(n||(n=new _Pact),2,e)}}(),n}function _forOf(e,t,r){if("function"==typeof e[_iteratorSymbol]){var n,i,o,c=e[_iteratorSymbol]();if(function _cycle(e){try{for(;!((n=c.next()).done||r&&r());)if((e=t(n.value))&&e.then){if(!_isSettledPact(e))return void e.then(_cycle,o||(o=_settle.bind(null,i=new _Pact,2)));e=e.v}i?_settle(i,1,e):i=e}catch(e){_settle(i||(i=new _Pact),2,e)}}(),c.return){var _fixup=function(e){try{n.done||c.return()}catch(e){}return e};if(i&&i.then)return i.then(_fixup,(function(e){throw _fixup(e)}));_fixup()}return i}if(!("length"in e))throw new TypeError("Object is not iterable");for(var s=[],a=0;a<e.length;a++)s.push(e[a]);return _forTo(s,(function(e){return t(s[e])}),r)}function validateJWE(e){if(!(e.protected&&e.iv&&e.ciphertext&&e.tag))throw new Error("bad_jwe: missing properties");e.recipients&&e.recipients.map((e=>{if(!e.header||!e.encrypted_key)throw new Error("bad_jwe: malformed recipients")}))}function encodeJWE({ciphertext:e,tag:t,iv:r,protectedHeader:n,recipient:i},o){const c={protected:n,iv:bytesToBase64url(r),ciphertext:bytesToBase64url(e),tag:bytesToBase64url(t)};return o&&(c.aad=bytesToBase64url(o)),i&&(c.recipients=[i]),c}const createJWE=function(e,t,r={},n){try{if("dir"===t[0].alg){if(t.length>1)throw new Error('not_supported: Can only do "dir" encryption to one key.');return Promise.resolve(t[0].encrypt(e,r,n)).then((function(e){return encodeJWE(e,n)}))}{const i=t[0].enc;if(!t.reduce(((e,t)=>e&&t.enc===i),!0))throw new Error("invalid_argument: Incompatible encrypters passed");let o,c;const s=_forOf(t,(function(t){const i=o?Promise.resolve(null==t.encryptCek?void 0:t.encryptCek(o)).then((function(e){var t,r;e&&(null==(t=c)||null==(r=t.recipients)||r.push(e))})):Promise.resolve(t.encrypt(e,r,n)).then((function(e){o=e.cek,c=encodeJWE(e,n)}));if(i&&i.then)return i.then((function(){}))}));return Promise.resolve(s&&s.then?s.then((function(){return c})):c)}}catch(e){return Promise.reject(e)}};function createX25519ECDH(e){if(32!==e.length)throw new Error("invalid_argument: incorrect secret key length for X25519");return function(t){try{if(32!==t.length)throw new Error("invalid_argument: incorrect publicKey key length for X25519");return Promise.resolve(x25519.sharedKey(e,t))}catch(e){return Promise.reject(e)}}}const resolveX25519Encrypters=function(e,t){try{const encryptersForDID=function(e,r=[]){try{return Promise.resolve(t.resolve(e)).then((function({didResolutionMetadata:t,didDocument:n}){function _temp4(){var t,r;const o=null==(t=n.keyAgreement)||null==(r=t.map((e=>"string"==typeof e?[...n.publicKey||[],...n.verificationMethod||[]].find((t=>t.id===e)):e)))?void 0:r.filter((e=>void 0!==e)),c=(null==o?void 0:o.filter((e=>"X25519KeyAgreementKey2019"===e.type&&Boolean(e.publicKeyBase58))))??[];if(!c.length&&!i.length)throw new Error(`no_suitable_keys: Could not find x25519 key for ${e}`);return c.map((e=>x25519Encrypter(base58ToBytes(e.publicKeyBase58),e.id))).concat(...i)}if(r.push(e),null!=t&&t.error||null==n)throw new Error(`resolver_error: Could not resolve ${e}: ${t.error}, ${t.message}`);let i=[];if(!n.controller&&!n.keyAgreement)throw new Error(`no_suitable_keys: Could not find x25519 key for ${e}`);const o=function(){if(n.controller){let e=Array.isArray(n.controller)?n.controller:[n.controller];e=e.filter((e=>!r.includes(e)));const t=e.map((e=>encryptersForDID(e,r).catch((()=>[]))));return Promise.resolve(Promise.all(t)).then((function(e){i=[].concat(...e)}))}}();return o&&o.then?o.then(_temp4):_temp4()}))}catch(e){return Promise.reject(e)}},r=e.map((e=>encryptersForDID(e)));return Promise.resolve(Promise.all(r)).then((function(e){return[].concat(...e)}))}catch(e){return Promise.reject(e)}};function createAuthEncrypter(e,t,r={}){return xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(e,t,r)}function createAnonEncrypter(e,t={}){return x25519Encrypter(e,null==t?void 0:t.kid)}function createAuthDecrypter(e,t){return xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(e,t)}function createAnonDecrypter(e){return x25519Decrypter(e)}function xc20pEncrypter(e){const t=new xchacha20poly1305.XChaCha20Poly1305(e);return(e,r)=>{const n=random.randomBytes(t.nonceLength),i=t.seal(n,e,r);return{ciphertext:i.subarray(0,i.length-t.tagLength),tag:i.subarray(i.length-t.tagLength),iv:n}}}function xc20pDirEncrypter(e){const t=xc20pEncrypter(e),r="XC20P",n="dir";return{alg:n,enc:r,encrypt:function(e,i={},o){try{const c=encodeBase64url(JSON.stringify(Object.assign({alg:n},i,{enc:r}))),s=fromString.fromString(o?`${c}.${bytesToBase64url(o)}`:c);return Promise.resolve({...t(e,s),protectedHeader:c})}catch(e){return Promise.reject(e)}}}}function xc20pDirDecrypter(e){const t=new xchacha20poly1305.XChaCha20Poly1305(e);return{alg:"dir",enc:"XC20P",decrypt:function(e,r,n){try{return Promise.resolve(t.open(r,e,n))}catch(e){return Promise.reject(e)}}}}function x25519Encrypter(e,t){const encryptCek=function(o){try{const c=x25519.generateKeyPair(),s=x25519.sharedKey(c.secretKey,e),a=xc20pEncrypter(concatKDF(s,n,r))(o),u={encrypted_key:bytesToBase64url(a.ciphertext),header:{alg:r,iv:bytesToBase64url(a.iv),tag:bytesToBase64url(a.tag),epk:{kty:"OKP",crv:i,x:bytesToBase64url(c.publicKey)}}};return t&&(u.header.kid=t),Promise.resolve(u)}catch(e){return Promise.reject(e)}},r="ECDH-ES+XC20PKW",n=256,i="X25519";return{alg:r,enc:"XC20P",encrypt:function(e,t={},r){try{Object.assign(t,{alg:void 0});const n=random.randomBytes(32);return Promise.resolve(xc20pDirEncrypter(n).encrypt(e,t,r)).then((function(e){return Promise.resolve(encryptCek(n)).then((function(t){return{...e,recipient:t,cek:n}}))}))}catch(e){return Promise.reject(e)}},encryptCek}}function xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(e,t,r={}){const encryptCek=function(a){try{function _temp2(){const e=new Uint8Array(l.length+d.length);e.set(l),e.set(d,l.length);const t=xc20pEncrypter(concatKDF(e,i,n,c,s))(a),f={encrypted_key:bytesToBase64url(t.ciphertext),header:{alg:n,iv:bytesToBase64url(t.iv),tag:bytesToBase64url(t.tag),epk:{kty:"OKP",crv:o,x:bytesToBase64url(u.publicKey)}}};return r.kid&&(f.header.kid=r.kid),r.apu&&(f.header.apu=r.apu),r.apv&&(f.header.apv=r.apv),f}const u=x25519.generateKeyPair(),l=x25519.sharedKey(u.secretKey,e);let d;const f=function(){if(!(t instanceof Uint8Array))return Promise.resolve(t(e)).then((function(e){d=e}));d=x25519.sharedKey(t,e)}();return Promise.resolve(f&&f.then?f.then(_temp2):_temp2())}catch(h){return Promise.reject(h)}},n="ECDH-1PU+XC20PKW",i=256,o="X25519";let c,s;return void 0!==r.apu&&(c=base64ToBytes(r.apu)),void 0!==r.apv&&(s=base64ToBytes(r.apv)),{alg:n,enc:"XC20P",encrypt:function(e,t={},r){try{Object.assign(t,{alg:void 0});const n=random.randomBytes(32);return Promise.resolve(xc20pDirEncrypter(n).encrypt(e,t,r)).then((function(e){return Promise.resolve(encryptCek(n)).then((function(t){return{...e,recipient:t,cek:n}}))}))}catch(e){return Promise.reject(e)}},encryptCek}}function validateHeader(e){if(!(e&&e.epk&&e.iv&&e.tag))throw new Error("bad_jwe: malformed header")}function x25519Decrypter(e){const t="ECDH-ES+XC20PKW",r=256,n="X25519";return{alg:t,enc:"XC20P",decrypt:function(i,o,c,s){try{var a,u;function _temp6(){const e=concatKDF(d,r,t),n=toSealed(s.encrypted_key,s.header.tag);return Promise.resolve(xc20pDirDecrypter(e).decrypt(n,base64ToBytes(s.header.iv))).then((function(e){return null===e?null:xc20pDirDecrypter(e).decrypt(i,o,c)}))}if(validateHeader(null==(a=s)?void 0:a.header),(null==(u=s.header.epk)?void 0:u.crv)!==n||void 0===s.header.epk.x)return Promise.resolve(null);const l=base64ToBytes(s.header.epk.x);let d;const f=function(){if(!(e instanceof Uint8Array))return Promise.resolve(e(l)).then((function(e){d=e}));d=x25519.sharedKey(e,l)}();return Promise.resolve(f&&f.then?f.then(_temp6):_temp6())}catch(h){return Promise.reject(h)}}}}function xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(e,t){const r="ECDH-1PU+XC20PKW",n=256,i="X25519";return{alg:r,enc:"XC20P",decrypt:function(o,c,s,a){try{var u;function _temp8(){const e=new Uint8Array(d.length+f.length);let t,i;e.set(d),e.set(f,d.length),a.header.apu&&(t=base64ToBytes(a.header.apu)),a.header.apv&&(i=base64ToBytes(a.header.apv));const u=concatKDF(e,n,r,t,i),l=toSealed(a.encrypted_key,a.header.tag);return Promise.resolve(xc20pDirDecrypter(u).decrypt(l,base64ToBytes(a.header.iv))).then((function(e){return null===e?null:xc20pDirDecrypter(e).decrypt(o,c,s)}))}if(validateHeader(a.header),(null==(u=a.header.epk)?void 0:u.crv)!==i||void 0===a.header.epk.x)return Promise.resolve(null);const l=base64ToBytes(a.header.epk.x);let d,f;const h=function(){if(!(e instanceof Uint8Array))return Promise.resolve(e(l)).then((function(r){return d=r,Promise.resolve(e(t)).then((function(e){f=e}))}));d=x25519.sharedKey(e,l),f=x25519.sharedKey(e,t)}();return Promise.resolve(h&&h.then?h.then(_temp8):_temp8())}catch(p){return Promise.reject(p)}}}}exports.ES256KSigner=ES256KSigner,exports.EdDSASigner=EdDSASigner,exports.EllipticSigner=EllipticSigner,exports.NaclSigner=NaclSigner,exports.SimpleSigner=SimpleSigner,exports.createAnonDecrypter=createAnonDecrypter,exports.createAnonEncrypter=createAnonEncrypter,exports.createAuthDecrypter=createAuthDecrypter,exports.createAuthEncrypter=createAuthEncrypter,exports.createJWE=createJWE,exports.createJWS=createJWS,exports.createJWT=createJWT,exports.createX25519ECDH=createX25519ECDH,exports.decodeJWT=decodeJWT,exports.decryptJWE=decryptJWE,exports.resolveX25519Encrypters=resolveX25519Encrypters,exports.toEthereumAddress=toEthereumAddress,exports.verifyJWS=verifyJWS,exports.verifyJWT=verifyJWT,exports.x25519Decrypter=x25519Decrypter,exports.x25519Encrypter=x25519Encrypter,exports.xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2=xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2,exports.xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2=xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2,exports.xc20pDirDecrypter=xc20pDirDecrypter,exports.xc20pDirEncrypter=xc20pDirEncrypter;